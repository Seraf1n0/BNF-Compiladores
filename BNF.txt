# Números, variables y asignaciones:

# -- Definir los tipos
<flotante> ::= (0.0) |-?0\ . [0-9]* [1-9]+|-?[1-9][0-9]* . ([0-9]*[1-9]+|0)

<entero> ::=  -? [1 - 9] [0 - 9]* | 0

#-- Las comillas son para indicar que es un simbolo literal terminal.
<booleano> ::= [ "true" | "false"]    

#-- En teoria esto: '[^']'     Significa, cualquier caracter menos la comilla ()')
<char> ::= '[^']'

<string> ::= #/"([^"\\] |\ \[nrt])*"/ #-- [ntr] es para cosas como \n, \r, \t


<operadorAritmetico> ::= (\+|\-|\*|\/|\/\/|%|\^)  #--[+\ | - | *\ | / | //]

<operadorLogico> ::= (@|~|Σ)

<operadorRelacional> ::= (==|!=|<=|>=|<|>)

#-- Alternativa con sin reguex <operador> ::= "+" | "-" | "*" | "/" | "//"

# -- Alternativa con reguex: <operador> ::= /(\+|\-|\*|\/|\/\/)/


<cAsignacion> ::= \=

<id> ::= [a-z A-Z ] [a-z A-Z 0-9 _]*

<delimitador> ::= $

<tipoVar> ::= "int" | "float" | "boolean" | "char" | "string" | "int[]" | "char[]"

<tipoFuncion> ::= "int" | "float" | "boolean" | "void"

<var> ::= <varCreacion> | <varCyAsignacion>

<varCreacion> ::= "let" <tipoVar> <id> <delimitador>

<varAsignacion> ::= <id> <cAsignacion> <expresion> <delimitador> | <id> <funcionLlamada> <delimitador>

<varCyAsignacion> ::= "let" <tipoVar> <id> <cAsignacion> <expresion> <delimitador>

# -- Las exresiones para una variables puden ser: nada mas numeros o caracteres, una operacion aritmetica o de union de caracteres, 
# -- tambien puede ser entrada de teclado o tambien se podria hacer una condicional para saber asignar un valor booleano.
<expresion> ::= <expresionNumerica> | <expresionAritmetica> | <expresionLiteral> | <expresionLogica> | <condicionBooleanda>

#-- Def de expresiones basicos.
<expresionNumerica> ::= <entero> | <flotante> | <id>

<expresionChar> ::= <char> | <id>

<expresionString> ::= <string> | <id>

<expresionBooleana> ::= <booleano> | <id>


# -- Def de operaciones de expresiones.
<expresionAritmetica> ::= <expresionNumerica> | \( <expresionAritmetica> \) | <expresionAritmetica> <operadorAritmetico> <expresionAritmetica>



#<expresionLiteral> ::= <expresionLiteral> \+ <expresionLiteral> # Esto no deberia de poder hacerse.



<expresionLogica> ::= <expresionRelacional>
                    | "(" <expresionLogica> ")"
                    | <expresionLogica> <operadorLogico> <expresionLogica>
                    | <operadorLogico> <expresionLogica>

<expresionRelacional> ::= <expresionNumerica> <operadorRelacional> <expresionNumerica> 
                        | <expresionChar> <operadorRelacional> <expresionChar> 
                        | <expresionString> <operadorRelacional> <expresionString>
                        | <expresionBooleana> <operadorRelacional> <expresionBooleana> 
                        | \( <expresionRelacional> \)



<expreioTeclado> ::= "input" \( <tipoVar>\)

# Funciones con estructuras de control, bloques y sentencias:

• Params -> params
• Params -> params, param
• Param -> var
• Funcion -> tipo id (\ \) bloque
• Funcion -> tipo id (\ params \) bloque
• Funcion -> funcion
• Funciones -> funcion

<funciones> ::= <funcion> | <funciones> <funcion>

<funcion> ::= <tipoFuncion> <id> \( <params> \) <bloque> | <tipoFuncion> <id> \( \) <bloque>

<params> ::= <param> | <params> , <param>

<param> ::= <tipoVar> <id>

<bloque> ::= ¿ <sentencias> \?

<sentencias> ::= <sentencia> | <sentencias> <sentencia>

<sentencia> ::= <var> | <varAsignacion> | <estructruraControl> | <comentarios> | <funcionLlamada> | <return> | <break> | <output>

<estructruraControl> ::= <decide> | <loop> | <for> # luego se definen abajo

<funcionLlamada> ::= <id> \( <params> \) <delimitador> | <id> \( \) <delimitador>

<return> ::= "return" <expresion> <delimitador> | "return" <delimitador>

<break> ::= "break" <delimitador>

<output> ::= "output" \( <expresion> \) <delimitador>

# Variables globales:

<varGlobal> ::= <varGlobalAsignacion> | <varGlobalCreacion>
<varGlobalAsignacion> ::= "global" <tipoVar> <id> <cAsignacion> <expresion> <delimitador>
<varGlobalCreacion> ::= "global" <tipoVar> <id> <delimitador>

# Tipos de variables enteras, flotantes, booleanas, caracteres, cadenas de caracteres y arreglos:

# Arreglos tipo char y entero; get y update de elementos, ser usados en expresiones y permitir creacion con asignacion:

# Sentencias para crear variables locales y globales, se asignan expresiones y pueden haber expresiones sin asignacion:


# Permitir expresiones combinadas con literales, variables, arreglos y/o funciones, de los tipos reconocidos por gramatica:

# Operadores y operandos respetando precedencia y permitir uso de parentesis:

# Expresiones aritmeticas binarias suma (+), resta (-), división (// y /) – entera o decimal según el tipo--, multiplicación (*), módulo (%) y potencia (^). Para enteros o reales:

# expresiones aritméticas unarias de negativo (-), ++ y -- después del operando; el negativo se puede aplicar a literales enteros y flotantes, el ++ y -- se aplica a variables enteras y flotantes:

# expresiones relacionales (sobre enteros y flotantes) de menor, menor o igual, mayor, mayor o igual, igual y diferente. Los operadores igual y diferente permiten adicionalmente tipo booleano.

# expresiones lógicas de conjunción (@), disyunción (~) y negación (ésta debe ser de tipo caracter (Σ)):

# Estructuras de control decide of, loop, for->to/downto->do, return y break:

# Funciones que leen enteros y flotantes y escribem cadenas de caracteres, booleans, enteros y flotantes (output y input palabras reservadas):

# Creación de funciones, retornar valores y recibir parametros con tipo especifico:

# Definición de unicamente un procedimiento main (principal) tipo void sin parametros:

# -- Def de main, puede cambiarse 
<inicio> ::= "void" "principal" \( \) ¿<sentencias>\?

#-- Def de un programa.
<programa> ::= <comentarioLinea>* <comentarioBloque>* <funciones>? <comentarioLinea>* <comentarioBloque>* <inicio> <comentarioLinea>* <comentarioBloque>*


# Comentarios en una linea o en multiples lineas:

#-- Estos podrian ser un monton de opciones mas.
<comentarioLinea> ::= |\sentencia

<comentarioBloque> ::= ¡sentencias! | -> #Aqui van los controles de flujo, funcion, loops, numeros, letras, 

• Main -> void main \( \) bloque
• Bloque -> ¿ sentencias ?
# cambiar sentencias, pueden ser un monton de opciones awiwiwiwi
• Sentencias -> sentencias sentencia
• Sentencias -> sentencia
• Sentencia -> assing
• Sentencia -> creacion
• Programa -> main
• Programa -> main funciones
• Programa -> funciones main
Programa -> funciones main funciones

