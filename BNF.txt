<espacio_blanco> ::= ' ' | '\t' | '\n' | '\r'
# Números, variables y asignaciones:

# -- Definir los tipos
<flotante> ::= (0.0) |-?0\ . [0-9]* [1-9]+|-?[1-9][0-9]* . ([0-9]*[1-9]+|0)

<entero> ::=  -? [1 - 9] [0 - 9]* | 0

<enteroPositivo> ::= [1 - 9] [0 - 9]* | 0

#-- Las comillas son para indicar que es un simbolo literal terminal.
<booleano> ::=  "true" | "false"    

#-- En teoria esto: '[^']'     Significa, cualquier caracter menos la comilla ()')
<char> ::= '[^']'

<string> ::= #/"([^"\\] |\ \[nrt])*"/ #-- [ntr] es para cosas como \n, \r, \t


<operadorAritmetico> ::= <operadorAritmeticoBase> | <operadorAritmeticoMDM> | <operadorAritmeticoPotencia> #(\+|\-|\*|\/|\/\/|%|\^)  #--[+\ | - | *\ | / | //]

<operadorAritmeticoBase> ::= (\+|\-)

<operadorAritmeticoMDM> ::= (\*|\/|\/\/|%)

<operadorAritmeticoPotencia> ::= (\^) 


<operadorLogico> ::= (@|~|Σ)

<operadorRelacional> ::= <operadorRelacionalMayores> | <operadorRelacionalIgualdad>

<operadorRelacionalMayores> ::= ("<="|">="|"<"|">")

<operadorRelacionalIgualdad> ::= ("=="|"!=")

#-- Alternativa con sin reguex <operador> ::= "+" | "-" | "*" | "/" | "//"

# -- Alternativa con reguex: <operador> ::= /(\+|\-|\*|\/|\/\/)/


<cAsignacion> ::= \=

<id> ::= [a-z A-Z ] [a-z A-Z 0-9 _]*

<delimitador> ::= $

<tipoVar> ::= "int" | "float" | "boolean" | "char" | "string" 

<tipoInput> ::= "int" | "float"

<tipoFuncion> ::= "int" | "float" | "boolean"

# -- Tipos de datos para definir listas.
<tipoLista> ::=  <tipoListaBase> | <tipoListaTamaño>

<tipoListaBase> ::= "int" "[" "]" | "char" "[" "]"

<tipoListaTamaño> ::= "int" "[" <entero> "]" | "char" "[" <entero> "]"

# -- Definir variables.
<var> ::= <varCreacion> | <varCyAsignacion>

<varCreacion> ::= "let" <espacio_blanco> <tipoVar> <espacio_blanco> <id> <delimitador>

<varAsignacion> ::= <id> <espacio_blanco> <cAsignacion> <espacio_blanco> <expresion> <delimitador> | <id> <espacio_blanco> <funcionLlamada> <delimitador>

<varCyAsignacion> ::= "let" <tipoVar> <id> <cAsignacion> <expresion> <delimitador>



# -- Las exresiones para una variables puden ser: nada mas numeros o caracteres, una operacion aritmetica o de union de caracteres, 
# -- tambien puede ser entrada de teclado o tambien se podria hacer una condicional para saber asignar un valor booleano.
<expresion> ::= <expresionNumerica> | <expresionAritmetica> | <expresionChar> | <expresionBooleana> | <expresionLogica> | <expresionRelacional>

#-- Def de expresiones basicos.
<expresionNumerica> ::= <entero> | <flotante> | <id> | <obtenerElementoLista>

<expresionChar> ::= <char> | <id>

<expresionString> ::= <string> | <id>

<expresionBooleana> ::= <booleano> | <id>


# -- Def de operaciones de expresiones, Construccion con orden de precedencia.
#<expresionAritmetica> ::= <expresionNumerica> | \( <expresionAritmetica> \) | <expresionAritmetica> <operadorAritmetico> <expresionAritmetica>

# -- La expresion aritmetica base.
<expresionAritmetica> ::= <expresionSuma>

# -- La base se puede formar por una operacion base o por una de prodcutos.
<expresionSuma> ::= <expresionSuma> <operadorAritmeticoBase> <expresionProducto>
                 | <expresionProducto>

# -- La de prodcuto esta conformada por la de productos o la de potencia.
<expresionProducto> ::= <expresionProducto> <operadorAritmeticoMDM> <expresionPotencia> #("*" | "/" | "//" | "%")
                      | <expresionPotencia>

# -- La de potencia esta formada por potencia o una de factor.
<expresionPotencia> ::= <expresionFactor> <operadorAritmeticoPotencia> <expresionPotencia>
                      | <expresionFactor>

# -- La de factor es el termino base para cualquier expresio aritmetia 
<expresionFactor> ::= "є" <expresionAritmetica> "э"
                    | <expresionNumerica>
                    | <expresionAritmeticaUnaria>
                    | <expresionAritmeticaUnariaNegativa>


# --Posfija
<expresionAritmeticaUnaria> ::= <id> "++" | <id> "--"

# -- Esto es basicamente para volver un valor negativo, por ejemplo: - 5 | - 3.34 | - x
<expresionAritmeticaUnariaNegativa> ::= "-" <expresionNumerica>


#<expresionLiteral> ::= <expresionLiteral> \+ <expresionLiteral> # Esto no deberia de poder hacerse.


# -- (@|~|Σ)
<expresionLogica> ::= <expresionRelacional>
                    | "є" <expresionLogica> "э"
                    | <expresionLogica> <operadorLogico> <expresionLogica>
                    | <operadorLogico> <expresionLogica>

# -- (==|!=|<=|>=|<|>)
<expresionRelacional> ::= <expresionNumerica> <operadorRelacional> <expresionNumerica> 
                        | <expresionBooleana> <operadorRelacionalIgualdad> <expresionBooleana> 
                        | "є" <expresionRelacional> "э"
                        #-- | <expresionChar> <operadorRelacional> <expresionChar> 
                        #-- | <expresionString> <operadorRelacional> <expresionString>


# -- Falta definir con mayor exactitud esto de la entrada.
<expreioTeclado> ::= "input" "є" <tipoVar> "э"

# Funciones con estructuras de control, bloques y sentencias:

• Params -> params
• Params -> params, param
• Param -> var
• Funcion -> tipo id (\ \) bloque
• Funcion -> tipo id (\ params \) bloque
• Funcion -> funcion
• Funciones -> funcion

<funciones> ::= <funcion> | <funciones> <funcion>

<funcion> ::= <tipoFuncion> <id> \( <params> \) <bloque> | <tipoFuncion> <id> \( \) <bloque>

<params> ::= <param> | <params> , <param>

<param> ::= <tipoVar> <id>

<bloque> ::= ¿ <espacio_blanco>* <sentencias> <espacio_blanco>* \?

<sentencias> ::= <sentencia> | <sentencias> <sentencia>

<sentencia> ::= <var> | <varAsignacion> | <estructruraControl> | <comentarios> | <funcionLlamada> | <return> | <break> | <output>

<estructruraControl> ::= <decide> | <loop> | <for> # luego se definen abajo

# Decide es de la forma decide of (condicion -> bloque)+ (else -> bloque)? end decide opcional
<decide> ::= "decide of" ( <condicion> "->" <bloque>)+ ("else" <bloque> )? "end" "decide" <delimitador>

<condicion> ::= "є" <expresion> "э"

# Loop es de la forma loop instrucciones... exit wgen condicion$ end loop$
<loop> ::= "loop" <sentencias> <break>? "exit when" <condicion> <delimitador> "end" "loop" <delimitador>

# For es de la forma for <id> step <entero> to/downto <expresion> do bloque
<for> ::= "for" <id> "step" <entero> ("to" | "downto") <expresion> "do" <bloque> <delimitador>

<funcionLlamada> ::= <id> "є" <params> "э" <delimitador> | <id> "є" "э"

<return> ::= "return" <expresion> <delimitador> | "return" <delimitador>

<break> ::= "break" <delimitador>

# El output puede ser de la forma output є expresion э o output є expresion э << output para multiples outputs en una linea.
<output> ::= <output_inline> | <output> "<<" <output_inline>

<output_inline> ::= "output" "є" <expresion> "э"

# Input puede ser de la forma input є tipo э
<input> ::= "input" "є" <tipoInput> "э" <delimitador>


# Variables globales:

<varGlobal> ::= <varGlobalAsignacion> | <varGlobalCreacion>
<varGlobalAsignacion> ::= "global" <tipoVar> <id> <cAsignacion> <expresion> <delimitador>
<varGlobalCreacion> ::= "global" <tipoVar> <id> <delimitador>

# Tipos de variables enteras, flotantes, booleanas, caracteres, cadenas de caracteres y arreglos:

# >>> Arreglos tipo char y entero; get y update de elementos, ser usados en expresiones y permitir creacion con asignacion:

# Declarar listas

<lista> ::= <declaracionLista> | <creacionYAsignacionLista>

# -- Declarar listas de forma basica
<declaracionLista> ::= "let" <tipoLista> <id> <delimitador>

# -- Esto es para crear una lista con asignacion: let int[] = ¿12,34?
<creacionYAsignacionLista> ::= "let" <tipoLista> <id> "=" "¿" <elementos> "?" "$" #<elementoLista> ("," <elementoLista>)*

#<elementos> ::= <elementoLista>

<elementos> ::= <elementoLista> ("," <elementoLista>)* #<elementos> "," <elementoLista>  

# -- Tipos de datos que puede tener una lista.
<elementoLista> ::= <entero> | <char>

# -- Modificar los elementos de una lista: lista[4] = 23$
<modificarElementoLista> ::= <id> "[" <enteroPositivo> "]" <cAsignacion> <elementoLista> <delimitador> | <id> "[" <id> "]" <cAsignacion> <elementoLista> <delimitador>

# -- Obtener los elementos de una lista: lista[4]    -> Esto puede ser usado en otras expresiones por lo que no lleva delimitador
<obtenerElementoLista> ::= <id> "[" <enteroPositivo> "]" | <id> "[" <id> "]"




# Sentencias para crear variables locales y globales, se asignan expresiones y pueden haber expresiones sin asignacion:


# Permitir expresiones combinadas con literales, variables, arreglos y/o funciones, de los tipos reconocidos por gramatica:

# Operadores y operandos respetando precedencia y permitir uso de parentesis:

# Expresiones aritmeticas binarias suma (+), resta (-), división (// y /) – entera o decimal según el tipo--, multiplicación (*), módulo (%) y potencia (^). Para enteros o reales:

# expresiones aritméticas unarias de negativo (-), ++ y -- después del operando; el negativo se puede aplicar a literales enteros y flotantes, el ++ y -- se aplica a variables enteras y flotantes:

# expresiones relacionales (sobre enteros y flotantes) de menor, menor o igual, mayor, mayor o igual, igual y diferente. Los operadores igual y diferente permiten adicionalmente tipo booleano.

# expresiones lógicas de conjunción (@), disyunción (~) y negación (ésta debe ser de tipo caracter (Σ)):

# Estructuras de control decide of, loop, for->to/downto->do, return y break:

# Funciones que leen enteros y flotantes y escribem cadenas de caracteres, booleans, enteros y flotantes (output y input palabras reservadas):

# Creación de funciones, retornar valores y recibir parametros con tipo especifico:

# Definición de unicamente un procedimiento main (principal) tipo void sin parametros:

# -- Def de main, puede cambiarse 
<inicio> ::= "void" "principal" \( \) ¿<sentencias>\?

#-- Def de un programa.
<programa> ::= <comentarioLinea>* <comentarioBloque>* <funciones>? <comentarioLinea>* <comentarioBloque>* <inicio> <comentarioLinea>* <comentarioBloque>*


# Comentarios en una linea o en multiples lineas:

#-- Estos podrian ser un monton de opciones mas.
<comentarioLinea> ::= |\sentencia

<comentarioBloque> ::= ¡sentencias! | -> #Aqui van los controles de flujo, funcion, loops, numeros, letras, 

• Main -> void main \( \) bloque
• Bloque -> ¿ sentencias ?
# cambiar sentencias, pueden ser un monton de opciones awiwiwiwi
• Sentencias -> sentencias sentencia
• Sentencias -> sentencia
• Sentencia -> assing
• Sentencia -> creacion
• Programa -> main
• Programa -> main funciones
• Programa -> funciones main
Programa -> funciones main funciones

